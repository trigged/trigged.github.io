<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Go 的一些调试技巧 · Hexo</title><meta name="description" content="Go 的一些调试技巧 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/solarized-light.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="https://avatars0.githubusercontent.com/u/3059605?s=460&amp;v=4" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/trigged" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">STACKOVERFLOW</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Go 的一些调试技巧</h1><div class="tags"></div><div class="post-info">Feb 27, 2018</div><div class="post-content"><p> 说起 Go 的优点，大家的第一反应基本都是并发，除此之外我觉得应该是 Go 的工具集，特别是 Go 的调试非常非常方便</p>
<h2 id="绕不过的-pprof"><a href="#绕不过的-pprof" class="headerlink" title="绕不过的 pprof"></a>绕不过的 pprof</h2><p> pprof 是内置调试工具之一可以非常方便的分析 CPU 和 内存的开销，找到热点函数，无论我们是通过 <code>import ”runtime/pprof&quot;</code> 还是 <code>&quot;net/http/pprof&quot;</code> 或者是 <code>go test -bench . -cpuprofile=cpu.prof</code> 来生成 prof 文件本质没有任何差别，最终调用的是同一段生成逻辑，这里我们需要关心的是生成出来的数据看什么</p>
<p>比如我们生成了一个 CPU profile 执行 <code>top10</code> 看到当前排名前十的热点函数开销，这么多数据我们究竟看什么？<br>建议优先看 <code>cum： 当前函数和其调用函数的开销</code> 然后在看 <code>flat： 当前函数开销</code><br>先看 cum 的原因在于 <code>flat</code> 高有可能是被调用了很多次，大部分都是系统函数，而 <code>cum</code> 我们可以看到一个整体，往往我们的问题代码都可以在这里看到，当然这并不是一个绝对</p>
<p> <img src="media/15199002816452.jpg" alt=""></p>
<p> pprof 还有很多其他有用的指令，比如 web 看到调用关系图，list 分析热点函数，更多的可以通过 help 来看</p>
<h2 id="trace-被忽视的主角"><a href="#trace-被忽视的主角" class="headerlink" title="trace 被忽视的主角"></a>trace 被忽视的主角</h2><p> 这是一个往往被大家忽视的工具，而且非常非常有用，集成也是非常简单这里以 web 为例<br> <code>curl host/debug/pprof/trace?seconds=10 &gt; trace.out</code> 这里我们生成 10s 内的数据，然后通过 <code>go tool trace trace.out</code> 如果数据量很大我们要等待一段时间，然后会在浏览器打开一个新的 tab 看起来非常的远古，但是里面的数据非常有用，特别是 view trace</p>
<p><img src="media/15199566649278.jpg" alt=""></p>
<p> 我们可以通过 view trace 了解到在此期间我们的程序跑的情况如何，我们随便先一个会进入下面这个界面，我们可以通过 wsad 当缩放，在这里我们可以看到 gc 的时间，STW 的影响，函数的调用栈，goroutine 的调度</p>
<p> <img src="media/15199011903121.jpg" alt=""></p>
<p>除此之外我们可以还可以通过<a href="https://github.com/divan/gotrace" target="_blank" rel="noopener">divan/gotrace</a> 把 goroutine 运行时的关系渲染出来<br><img src="media/15199565799062.jpg" alt=""></p>
<h2 id="持续的生态"><a href="#持续的生态" class="headerlink" title="持续的生态"></a>持续的生态</h2><p>go tool 已经十分完善了，我们可以通过 <code>objdump</code> 看到 asm , 也可以通过 <code>race</code>  来检测并发，生态也越发丰富，社区在不断共享更简单易用的调试工具。我们可以通过 <a href="https://github.com/google/pprof" target="_blank" rel="noopener">google/pprof</a> 或者 <a href="https://github.com/uber/go-torch" target="_blank" rel="noopener">uber/go-torch</a> 直接生成火焰图，这个简直比 Node 要方便太多<br>以 pprof 为例，我们只需一句即可即可生成强力的火焰图<br><code>pprof -http :3001 binary http://host/debug/pprof/profile</code></p>
<p><img src="media/15199017769737.jpg" alt=""></p>
<p>同时最近 google 又推出了一个 <a href="https://github.com/google/gops" target="_blank" rel="noopener">gops</a>, 让我们可以很快速的筛选出 go 程序不需要在通过 ps 来筛选，而且可以很方便的生成 trace </p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>最后分享一些看到比较精彩的 Go Debug 案例，我们遇到类似的问题或许可以找到思路</p>
<p><a href="https://gocn.io/article/441" target="_blank" rel="noopener">如何定位 golang 进程 hang 死的 bug </a> （在 18年的 gopher conf 中有 arm 的大佬提到这个问题可能会在 2.0 中解决）</p>
<p><a href="https://gocn.io/article/340" target="_blank" rel="noopener">记一次Go websocket　项目内存泄露排查 + 使用Go pprof定位内存泄露 </a></p>
<h2 id="最最重要的"><a href="#最最重要的" class="headerlink" title="最最重要的"></a>最最重要的</h2><p>不要一开始过度优化这个是基本的共识，除此之外，一定要用最新的版本编译，已经有很多血淋淋的案例发生</p>
<p>除了上述工具外我们还可以的在 build 的时候我们可以加入一些 flag 可以看 GC, 逃逸分析，Goroutine 调度等相关选项，甚至通过 objdump 来看 asm</p>
<p>当 pprof 无效的时候，不要忘记我们还有 strace， perf， dtrace 可以用，这些都是无上的杀招</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">Profiling Go Programs - The Go Blog</a><br><a href="https://github.com/google/gops" target="_blank" rel="noopener">list and diagnose Go processes</a><br><a href="http://cizixs.com/2017/09/11/profiling-golang-program" target="_blank" rel="noopener">使用 pprof 和火焰图调试 golang 应用 – Cizixs Writes Here</a><br><a href="https://making.pusher.com/go-tool-trace/" target="_blank" rel="noopener">go tool trace - Making Pusher</a><br><a href="https://blog.gopheracademy.com/advent-2017/go-execution-tracer/" target="_blank" rel="noopener">go-execution-tracer</a><br><a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="noopener">pprof - The Go Programming Language</a><br><a href="https://divan.github.io/posts/go_concurrency_visualize/" target="_blank" rel="noopener">Visualizing Concurrency in Go ·  divan’s blog</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/01/24/go-fork/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-117515834-1",'auto');ga('send','pageview');</script><script>$(document).ready(function() { $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>